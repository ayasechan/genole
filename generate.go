package main

import (
	"fmt"
	"strconv"
	"strings"

	. "github.com/dave/jennifer/jen"
)

const (
	GO_OLE_PATH = "github.com/go-ole/go-ole"
)

type IdlFlag string

const (
	IDL_OUT    IdlFlag = "out"
	IDL_IN     IdlFlag = "in"
	IDL_RETVAL IdlFlag = "retval"
	IDL_LCID   IdlFlag = "lcid"
)

type ComClass struct {
	Name    string      `yaml:"className"`
	From    string      `yaml:"from"`
	Methods []ComMethod `yaml:"methods"`
	IID     string      `yaml:"iid"`
}

type ComMethod struct {
	Name    string   `yaml:"name"`
	Comment string   `yaml:"comment"`
	Args    []ComArg `yaml:"args"`
}

type ComArg struct {
	Name      string    `yaml:"name"`
	Type      string    `yaml:"type"`
	Flags     []IdlFlag `yaml:"idlFlags"`
	IsPointer bool      `yaml:"isPointer"`
}

func (arg *ComArg) IsContainFlag(flag IdlFlag) bool {
	r := false
	for _, v := range arg.Flags {
		if flag == v {
			r = true
			break
		}
	}
	return r
}

func GenHeader(pkg string) *File {
	f := NewFile(pkg)
	f.HeaderComment("// Code generated by genole; DO NOT EDIT.")
	f.Line()
	f.ImportName("syscall", "")
	f.ImportName("unsafe", "")
	f.ImportName(GO_OLE_PATH, "ole")
	return f
}

// key 是包的路径
// value 是导入的别名
func GenExtraImport(pkgs map[string]string) *Statement {
	body := Empty()
	for k, v := range pkgs {
		body.Id(v).Lit(k)
		body.Line()
	}
	return Id("import").Parens(body)
}

func GenClass(def ComClass) *Statement {
	s := Line()

	// iid
	s.Var().Id(fmt.Sprintf("IID_%s", def.Name)).Op("=").Qual(GO_OLE_PATH, "NewGUID").Params(Lit(def.IID))
	s.Line()

	// class
	s.Type().Id(def.Name).Struct(Id(def.From))
	s.Line()

	// class vtable
	s.Type().Id(GetVtableName(def.Name))
	s.StructFunc(func(g *Group) {
		g.Id(GetVtableName(def.From))
		for _, method := range def.Methods {
			g.Id(method.Name).Uintptr()
		}
	})
	s.Line()

	// vtable function
	s.Func().Params(Id("v").Op("*").Id(def.Name))
	s.Id("VTable")
	s.Params()
	s.Op("*").Id(GetVtableName(def.Name))
	s.Block(
		Return(Parens(Op("*").Id(GetVtableName(def.Name))).Parens(
			Qual("unsafe", "Pointer").Call(Id("v").Dot("RawVTable")),
		)),
	)
	s.Line()

	return s
}

func GenMethod(className string, def ComMethod) *Statement {
	// TODO generate comment from argument define
	fn := Comment(def.Comment)
	fn.Line()
	fn.Func().Params(Id("v").Id(fmt.Sprintf("*%s", className))).Id(def.Name)

	// 函数参数
	// TODO hsting
	fn.ParamsFunc(func(g *Group) {
		for _, arg := range def.Args {
			if arg.IsContainFlag(IDL_RETVAL) {
				continue
			}
			if arg.IsContainFlag(IDL_OUT) {
				g.Id(arg.Name).Uintptr()
				continue
			}
			g.Id(arg.Name).Id(arg.Type)
		}
	})

	// 函数返回值
	fn.ParamsFunc(func(g *Group) {
		for _, arg := range def.Args {
			if !arg.IsContainFlag(IDL_RETVAL) {
				continue
			}
			g.Id(arg.Type)
		}
		g.Error()
	})

	// 函数体
	body := Empty()

	// 定义返回值
	for i, arg := range def.Args {
		if !arg.IsContainFlag(IDL_RETVAL) {
			continue
		}
		body.Var().Id(fmt.Sprintf("%s_%d", arg.Name, i)).Id(arg.Type)
		body.Line()
	}

	// syscall
	// in
	// 1. uintptr 直接传
	// 2. 非指针 uintptr(unsafe.Pointer(&v))
	// 3. 指针 uintptr(unsafe.Pointer(v))
	// 4. 整数 uintptr(v)
	// out
	// 1. 非 retval 定义函数参数时一律用 uintptr 调用时直接调
	// 2. retval 定义为指定的类型 然后 uintptr(unsafe.Pointer(&v))
	syscallArgs := []string{"uintptr(unsafe.Pointer(v))"}
	for i, arg := range def.Args {
		name := arg.Name
		if arg.IsContainFlag(IDL_OUT) {
			if arg.IsContainFlag(IDL_RETVAL) {
				name = fmt.Sprintf("uintptr(unsafe.Pointer(&%s_%d))", name, i)
			}
		} else {
			switch {
			case arg.Type == "uintptr":
			case isInteger(arg.Type):
				name = fmt.Sprintf("uintptr(%s)", name)
			case strings.HasPrefix(arg.Type, "*") || arg.IsPointer:
				name = fmt.Sprintf("uintptr(unsafe.Pointer(%s))", name)
			default:
				name = fmt.Sprintf("uintptr(unsafe.Pointer(&%s))", name)
			}
		}
		syscallArgs = append(syscallArgs, name)
	}
	body.List(Id("hr"), Id("_"), Id("_")).Op(":=")
	body.Add(GenSyscall(fmt.Sprintf("v.VTable().%s", def.Name), syscallArgs...))

	// error handle
	body.Line()
	body.Var().Err().Error()
	body.Line()
	body.If(Id("hr").Op(">").Id("0"))
	body.Block(
		Err().Op("=").Qual(GO_OLE_PATH, "NewError").Call(Id("hr")),
	)
	body.Line()

	// return
	body.ReturnFunc(func(g *Group) {
		for i, arg := range def.Args {
			if !arg.IsContainFlag(IDL_RETVAL) {
				continue
			}
			g.Id(fmt.Sprintf("%s_%d", arg.Name, i))
		}
		g.Err()
	})

	fn.Block(body)
	return fn
}

func GenSyscall(addr string, args ...string) *Statement {
	method := `Syscall`
	extraSyscallArgsNum := 0

	switch {
	case len(args) < 3:
		extraSyscallArgsNum = 3 - len(args)
	case len(args) < 6:
		method = "Syscall6"
		extraSyscallArgsNum = 6 - len(args)
	case len(args) < 9:
		method = "Syscall9"
		extraSyscallArgsNum = 9 - len(args)
	case len(args) < 12:
		method = "Syscall12"
		extraSyscallArgsNum = 12 - len(args)
	case len(args) < 15:
		method = "Syscall15"
		extraSyscallArgsNum = 15 - len(args)
	case len(args) < 18:
		method = "Syscall18"
		extraSyscallArgsNum = 18 - len(args)
	default:
		panic("too many argumets")
	}

	return Qual("syscall", method).CallFunc(func(g *Group) {
		g.Id(addr)
		g.Id(strconv.Itoa(len(args)))
		for _, arg := range args {
			g.Id(arg)
		}
		for i := 0; i < extraSyscallArgsNum; i++ {
			g.Lit(0)
		}
	})
}

// onErr 外面必须包一层 block
func toHstring(src, dst string, onErr *Statement) *Statement {
	s := Line()
	s.List(Id(dst), Err()).Op(":=").Qual(GO_OLE_PATH, "NewHString").Params()
	s.Line()
	s.Add(IFErrNENil, onErr)
	s.Defer().Qual(GO_OLE_PATH, "DeleteHString").Call(Id(dst))
	return s
}
